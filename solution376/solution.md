# [solution376](https://leetcode-cn.com/problems/wiggle-subsequence/)
## description
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

### 解法一动态规划
我们要找到给定数组nums中的最大摆动子序列，我们可以找到以每一个元素结尾的最大子序列，然后选取其中最大的则为给定数组的最大子序列长度。为此我们可以假设有一个dp数组，其中dp[i]表示以i结尾的最大摆动子序列。所以:
> dp[i] = max(dp[j]+1),j<i
    
但是，我们需要求的是摆动序列，也就是在进行对比的时候要知道当前dp[j]所在的元素是上升还是下降，且当前的值nums[i] 与nums[j] 的大小符合摆动序列的定义才可以参与计算dp[i] = max(dp[j]+1)，为此我们还需要携带上摆动的信息；设dp[][],其中dp[0][i]表示以i结尾的最大摆动序列长度，dp[1][i]表示当前i结尾的元素是上升(元素值为1)还是下降（元素值为-1），因此递推公式如下:
> dp[0][i] = max(dp[0][j] + 1),j<i,且 (nums[i] - nums[j])*dp[0][j] < 0    
> dp[1][i] = nums[i] -nums[j] > 0 ? 1:-1;
    
综上，该解法的空间复杂度为O(n),时间复杂度为O(n^2)。
